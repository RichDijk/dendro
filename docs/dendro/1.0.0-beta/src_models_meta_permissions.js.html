<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>src/models/meta/permissions.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#arrayContainsArray">arrayContainsArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildCkanFileIDsFromDendroFileNames">buildCkanFileIDsFromDendroFileNames</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildExtrasJSONArray">buildExtrasJSONArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildPackageForCkanExport">buildPackageForCkanExport</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildPermissionsToBeCheck">buildPermissionsToBeCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#calculateCkanRepositoryDiffs">calculateCkanRepositoryDiffs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#calculateDendroDiffs">calculateDendroDiffs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkIfFolderAndTargetRepositoryHaveRequiredMetadata">checkIfFolderAndTargetRepositoryHaveRequiredMetadata</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkIfResourceHasTheRequiredMetadataForExport">checkIfResourceHasTheRequiredMetadataForExport</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkPrivacyOfProject">checkPrivacyOfProject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkResourceTypeAndChildren">checkResourceTypeAndChildren</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#checkRoleInSystem">checkRoleInSystem</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#Config">Config</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createCkanFileIdBasedOnDendroFileName">createCkanFileIdBasedOnDendroFileName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createOrUpdateFilesInPackage">createOrUpdateFilesInPackage</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createPackageID">createPackageID</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createPackageInCkan">createPackageInCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#deleteResourceInCkan">deleteResourceInCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#exportPackageToCkan">exportPackageToCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#get_recommendations">get_recommendations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getAllPosts">getAllPosts</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getBothDendroDiffsAndCkanDiffs">getBothDendroDiffsAndCkanDiffs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getExportedAtByDendroForCkanDataset">getExportedAtByDendroForCkanDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#isObject">isObject</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#jarPath">jarPath</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#mergeDeep">mergeDeep</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#purgeCkanDataset">purgeCkanDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#register_interaction">register_interaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#repository_types">repository_types</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#request">request</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#updateOrInsertExportedAtByDendroForCkanDataset">updateOrInsertExportedAtByDendroForCkanDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#updatePackageInCkan">updatePackageInCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#validateChangesPermissions">validateChangesPermissions</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#verifyIfCkanFileWasCreatedInDendro">verifyIfCkanFileWasCreatedInDendro</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">src/models/meta/permissions.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require("path");
const rlequire = require("rlequire");
const Config = rlequire("dendro", "src/models/meta/config.js").Config;
const Logger = rlequire("dendro", "src/utils/logger.js").Logger;

const isNull = rlequire("dendro", "src/utils/null.js").isNull;

const Resource = rlequire("dendro", "src/models/resource.js").Resource;
const InformationElement = rlequire("dendro", "src/models/directory_structure/information_element.js").InformationElement;
const File = rlequire("dendro", "src/models/directory_structure/file.js").File;
const Folder = rlequire("dendro", "src/models/directory_structure/folder.js").Folder;
const User = rlequire("dendro", "src/models/user.js").User;
const Project = rlequire("dendro", "src/models/project.js").Project;
const Deposit = rlequire("dendro", "src/models/deposit.js").Deposit;
const ConditionsAcceptance = rlequire("dendro", "src/models/conditionsAcceptance.js").ConditionsAcceptance;
const Post = rlequire("dendro", "src/models/social/post.js").Post;
const Notification = rlequire("dendro", "src/models/notifications/notification.js").Notification;

const async = require("async");
const _ = require("underscore");

const db_social = Config.getDBByID("social");
const db_notifications = Config.getDBByID("notifications");

function Permissions ()
{}

Permissions.messages = {
    generic: {
        api: "Generic authentication error, Error detected. You are not authorized to perform this operation. You must be signed into Dendro.",
        user: "Generic authentication error, are you logged in? Please log into the system."
    }
};

Permissions.sendResponse = function (allowAccess, req, res, next, reasonsForAllowingOrDenying, errorMessage)
{
    let acceptsHTML = req.accepts("html");
    const acceptsJSON = req.accepts("json");

    if (allowAccess)
    {
        if (Config.debug.permissions.log_authorizations)
        {
            let user = "-> NO USER AUTHENTICATED &lt;-";
            if (req.user)
            {
                user = req.user.uri;
            }

            Logger.log("[ALLOW-ACCESS] User " + user + " granted access to " + req.originalUrl + " .");
        }

        return next();
    }

    let messageAPI;
    let messageUser;

    if (!isNull(errorMessage) &amp;&amp; errorMessage !== "")
    {
        messageAPI = errorMessage;
        messageUser = errorMessage;
    }
    else
    {
        messageAPI = "";
        messageUser = "";

        _.map(reasonsForAllowingOrDenying, function (reason)
        {
            if (messageAPI !== "")
            {
                messageAPI = reason.role.error_message_api + "\n" + messageAPI;
            }
            else
            {
                messageAPI = reason.role.error_message_api;
            }

            if (messageUser !== "")
            {
                messageUser = reason.role.error_message_user + "\n" + messageUser;
            }
            else
            {
                messageUser = reason.role.error_message_user;
            }
        });
    }

    if (messageUser === "" || isNull(messageUser))
    {
        messageUser = Permissions.messages.generic.user;
    }

    if (messageAPI === "" || isNull(messageAPI))
    {
        messageAPI = Permissions.messages.generic.api;
    }

    req.permissions_management = {
        reasons_for_denying: reasonsForAllowingOrDenying
    };

    if (Config.debug.permissions.log_authorizations)
    {
        let user = "-> NO USER AUTHENTICATED &lt;-";
        if (!isNull(req.user))
        {
            user = req.user.uri;
        }

        Logger.log("[DENY-ACCESS] User " + user + " denied access to " + req.originalUrl + " . Reasons: " + messageUser);
    }

    // will be null if the client does not accept html
    if (acceptsJSON &amp;&amp; !acceptsHTML)
    {
        return res.status(401).json(
            {
                result: "error",
                message: messageAPI
            }
        );
    }

    req.flash("error", messageUser);

    if (req.user)
    {
        return res.status(401).render("index",
            {
                error_messages: [messageUser]
            });
    }

    return res.status(401).render("auth/login", {
        error_messages: [messageUser],
        redirect: req.url
    });
};

const getOwnerProject = function (requestedResource, callback)
{
    InformationElement.findByUri(requestedResource, function (err, resource)
    {
        if (isNull(err))
        {
            if (!isNull(resource))
            {
                if (resource instanceof InformationElement)
                {
                    resource.getOwnerProject(function (err, project)
                    {
                        if (!isNull(project) &amp;&amp; project instanceof Project)
                        {
                            callback(null, project);
                        }
                        else
                        {
                            callback(null, project);
                        }
                    });
                }
                else
                {
                    callback("Resource " + requestedResource + " is of invalid type!", null);
                }
            }
            else
            {
                callback(null, null);
            }
        }
        else
        {
            callback(err, resource);
        }
    });
};

const getDeposit = function (requestedResource, callback)
{
    InformationElement.findByUri(requestedResource, function (err, resource)
    {
        if (isNull(err))
        {
            if (!isNull(resource))
            {
                if (resource instanceof InformationElement)
                {
                    resource.getOwnerDeposit(function (err, deposit)
                    {
                        callback(err, deposit);
                    });
                }
                else
                {
                    callback("Resource " + requestedResource + " is of invalid type!", null);
                }
            }
            else
            {
                Deposit.findByUri(requestedResource, function (err, deposit)
                {
                    callback(err, deposit);
                });
            }
        }
        else
        {
            callback(err, resource);
        }
    });
};

const getCondition = function (user, dataset, callback)
{
    ConditionsAcceptance.getCondition(user, dataset, function (err, condition)
    {
        if (isNull(err))
        {
            if (condition.length)
            {
                callback(err, condition[0]);
            }
            else
            {
                callback(err, null);
            }
        }
        else
        {
            callback(1, err);
        }
    });
};
/** Role-based validation **/

const checkRoleInSystem = Permissions.checkRoleInSystem = function (req, user, role, callback)
{
    if (!isNull(user))
    {
        user.checkIfHasPredicateValue(role.predicate, role.object, function (err, result)
        {
            return callback(err, result);
        });
    }
    else
    {
        callback(null, false);
    }
};

const checkUsersRoleInProject = function (req, user, role, project, callback)
{
    if (!isNull(user))
    {
        if (project instanceof Project)
        {
            project.checkIfHasPredicateValue(role.predicate, user.uri, function (err, result)
            {
                return callback(err, result);
            });
        }
        else if (typeof project === "string")
        {
            Project.findByUri(project, function (err, project)
            {
                if (isNull(err) &amp;&amp; project instanceof Project)
                {
                    project.checkIfHasPredicateValue(role.predicate, user.uri, function (err, result)
                    {
                        return callback(err, result);
                    });
                }
                else
                {
                    return callback(err, null);
                }
            });
        }
        else
        {
            return callback("Invalid project type supplied!", null);
        }
    }
    else
    {
        return callback(null, false);
    }
};

const getPostsProject = function (postUri, callback)
{
    Post.findByUri(postUri, function (err, post)
    {
        if (isNull(err))
        {
            if (!isNull(post))
            {
                if (post instanceof Post)
                {
                    post.getOwnerProject(function (err, project)
                    {
                        if (!isNull(project) &amp;&amp; project instanceof Project)
                        {
                            callback(null, project);
                        }
                        else
                        {
                            callback(err, project);
                        }
                    });
                }
                else
                {
                    callback("Resource " + postUri + " is of invalid type!", null);
                }
            }
            else
            {
                callback(null, null);
            }
        }
        else
        {
            callback(err, post);
        }
    }, null, db_social.graphUri, false, null, null);
};

const checkUsersRoleInNotification = function (req, user, role, notificationUri, callback)
{
    if (!isNull(user))
    {
        Notification.findByUri(notificationUri, function (err, notification)
        {
            if (isNull(err))
            {
                if (isNull(notification))
                {
                    return callback(null, true);
                }
                else if (notification instanceof Notification)
                {
                    notification.checkIfHasPredicateValue(role.predicate, user.uri, function (err, result)
                    {
                        return callback(err, result);
                    }, db_notifications.graphUri);
                }
                else
                {
                    return callback(null, false);
                }
            }
            else
            {
                return callback(null, false);
            }
        }, null, db_notifications.graphUri, false, null, null);
    }
    else
    {
        callback(null, false);
    }
};

const checkUsersRoleInPostsProject = function (req, user, role, postUri, callback)
{
    if (!isNull(user))
    {
        getPostsProject(postUri, function (err, project)
        {
            if (isNull(err))
            {
                if (project instanceof Project)
                {
                    checkUsersRoleInProject(req, user, role, project, function (err, hasRole)
                    {
                        return callback(err, hasRole);
                    });
                }
                else
                {
                    return callback(null, false);
                }
            }
            else
            {
                return callback(null, false);
            }
        });
    }
    else
    {
        callback(null, false);
    }
};

const checkUsersRoleInArrayOfPostsProject = function (req, user, role, arrayOfPostsUris, callback)
{
    let predicateRoles = null;
    if (isNull(role) || isNull(role.predicates) || !(role.predicates instanceof Array) || isNull(arrayOfPostsUris) || !(arrayOfPostsUris instanceof Array))
    {
        Logger.log("error", "Error at checkUsersRoleInArrayOfPostsProject, 'role' object should exist and 'role.predicates' and arrayOfPostsUris must be an array!");
        callback(null, false);
    }
    else
    {
        predicateRoles = role.predicates;
        if (!isNull(user))
        {
            if (arrayOfPostsUris.length > 0)
            {
                async.mapSeries(arrayOfPostsUris, function (postUri, cb)
                {
                    getPostsProject(postUri, function (err, project)
                    {
                        if (isNull(err))
                        {
                            if (project instanceof Project)
                            {
                                async.eachSeries(predicateRoles, function (predicate, cb)
                                {
                                    let role = {
                                        predicate: predicate
                                    };
                                    checkUsersRoleInProject(req, user, role, project, function (err, hasRole)
                                    {
                                        if (isNull(err))
                                        {
                                            if (hasRole === true)
                                            {
                                                return callback(err, hasRole);
                                            }
                                            cb(err, hasRole);
                                        }
                                        else
                                        {
                                            return callback(err, false);
                                        }
                                    });
                                }, function (err)
                                {
                                    return callback(null, false);
                                });
                            }
                            else
                            {
                                return callback(null, false);
                            }
                        }
                        else
                        {
                            return callback(null, false);
                        }
                    });
                }, function (err, results)
                {
                    return callback(null, false);
                });
            }
            else
            {
                // when there are no posts in the timeline it is always allowed to check the "empty" timeline
                return callback(null, true);
            }
        }
        else
        {
            callback(null, false);
        }
    }
};

const checkUsersRoleInParentProject = Permissions.checkUsersRoleInParentProject = function (req, user, role, resource, callback)
{
    if (!isNull(user))
    {
        getOwnerProject(resource, function (err, project)
        {
            if (isNull(err))
            {
                if (project instanceof Project)
                {
                    checkUsersRoleInProject(req, user, role, project, function (err, hasRole)
                    {
                        return callback(err, hasRole);
                    });
                }
                else
                {
                    return callback(null, false);
                }
            }
            else
            {
                return callback(err, false);
            }
        });
    }
    else
    {
        callback(null, false);
    }
};

const checkUsersPermissionOnDeposit = function (req, user, role, depositUri, callback)
{
    let predicateRoles = null;
    if (isNull(role) || isNull(role.predicates) || !(role.predicates instanceof Array))
    {
        Logger.log("error", "Error at checkUsersRoleInDeposit, 'role' object should exist and 'role.predicates' and arrayOfPostsUris must be an array!");
        callback(null, false);
    }
    else
    {
        predicateRoles = role.predicates;
        if (!isNull(user) &amp;&amp; !isNull(depositUri))
        {
            if (req.session.isAdmin === true)
            {
                return callback(null, true);
            }
            getDeposit(depositUri, function (err, deposit)
            {
                if (isNull(err))
                {
                    if (deposit.dcterms.creator === user.uri)
                    {
                        return callback(null, true);
                    }
                    if (deposit.ddr.privacyStatus === "public" &amp;&amp; isNull(deposit.ddr.accessTerms))
                    {
                        return callback(null, true);
                    }
                    getCondition(user.uri, depositUri, function (err, condition)
                    {
                        if (isNull(err) &amp;&amp; condition !== null)
                        {
                            if (condition.userAccepted === "true")
                            {
                                return callback(null, true);
                            }
                            return callback(null, false);
                        }

                        return callback(null, false);
                    });
                }
                else callback(err, false);
            });
        }
        else
        {
            return callback(null, false);
        }
    }
};

const checkUsersRoleInDeposit = function (req, user, role, depositUri, callback)
{
    let predicateRoles = null;
    if (isNull(role) || isNull(role.predicates) || !(role.predicates instanceof Array))
    {
        Logger.log("error", "Error at checkUsersRoleInDeposit, 'role' object should exist and 'role.predicates' and arrayOfPostsUris must be an array!");
        callback(null, false);
    }
    else
    {
        predicateRoles = role.predicates;
        if (!isNull(user) &amp;&amp; !isNull(depositUri))
        {
            getDeposit(depositUri, function (err, deposit)
            {
                if (isNull(err) &amp;&amp; deposit instanceof Deposit)
                {
                    async.eachSeries(predicateRoles, function (predicate, cb)
                    {
                        deposit.checkIfHasPredicateValue(predicate, user.uri, function (err, result)
                        {
                            if (isNull(err))
                            {
                                if (result === true)
                                {
                                    return callback(err, result);
                                }

                                cb(err, result);
                            }
                            else
                            {
                                return callback(err, false);
                            }
                        });
                    }, function (err)
                    {
                        return callback(null, false);
                    });
                }
                else
                {
                    return callback(null, false);
                }
            });
        }
        else
        {
            return callback(null, false);
        }
    }
};

/** "Privacy status"-based validation **/

const checkPrivacyOfProject = function (req, permission, callback)
{
    Project.findByUri(req.params.requestedResourceUri, function (err, project)
    {
        if (isNull(err))
        {
            if (!isNull(project) &amp;&amp; project instanceof Project)
            {
                const privacy = project.ddr.privacyStatus;

                if (!isNull(permission.object) &amp;&amp; privacy === permission.object)
                {
                    return callback(null, true);
                }
                return callback(null, false);
            }
            return callback(null, true);
        }
        return callback(err, true);
    });
};

const checkPrivacyOfOwnerProject = function (req, user, role, resource, callback)
{
    getOwnerProject(resource, function (err, project)
    {
        if (isNull(err))
        {
            if (!isNull(project) &amp;&amp; project instanceof Project)
            {
                const privacy = project.ddr.privacyStatus;

                if (!isNull(role.object) &amp;&amp; privacy === role.object)
                {
                    return callback(null, true);
                }
                return callback(null, false);
            }
            return callback(null, false);
        }
        return callback(err, null);
    });
};

const checkOwnerDeposit = function (req, user, role, resource, callback)
{
    getDeposit(resource, function (err, deposit)
    {
        if (isNull(err))
        {
            if (!isNull(deposit) &amp;&amp; deposit instanceof Deposit)
            {
                return callback(null, true);
            }
            return callback(null, false);
        }
        return callback(err, null);
    });
};

const checkPrivacyOfDeposit = function (req, user, role, resource, callback)
{
    getDeposit(resource, function (err, deposit)
    {
        if (isNull(err))
        {
            if (!isNull(deposit) &amp;&amp; deposit instanceof Deposit)
            {
                const privacy = deposit.ddr.privacyStatus;

                if (!isNull(role.object) &amp;&amp; privacy === role.object)
                {
                    return callback(null, true);
                }
                return callback(null, false);
            }
            return callback(null, false);
        }
        return callback(err, null);
    });
};

/** Permission types **/

Permissions.types = {
    role_in_system: {
        validator: checkRoleInSystem
    },
    role_in_project: {
        validator: checkUsersRoleInProject
    },
    role_in_owner_project: {
        validator: checkUsersRoleInParentProject
    },
    role_in_post_s_project: {
        validator: checkUsersRoleInPostsProject
    },
    user_role_in_array_of_posts_project: {
        validator: checkUsersRoleInArrayOfPostsProject
    },
    role_in_notification_s_resource: {
        validator: checkUsersRoleInNotification
    },
    role_in_deposit: {
        validator: checkUsersRoleInDeposit
    },
    permission_on_deposit: {
        validator: checkUsersPermissionOnDeposit
    },
    privacy_of_project: {
        validator: checkPrivacyOfProject
    },
    privacy_of_owner_project: {
        validator: checkPrivacyOfOwnerProject
    },
    privacy_of_deposit: {
        validator: checkPrivacyOfDeposit
    },
    owner_deposit: {
        validator: checkOwnerDeposit
    }
};

/** Permission parametrization **/

Permissions.settings = {
    role: {
        in_system: {
            admin: {
                type: Permissions.types.role_in_system,
                predicate: "rdf:type",
                object: "ddr:Administrator",
                error_message_user: "You are not authorized to perform this operation. You must be a Dendro administrator.",
                error_message_api: "Error detected. You are not authorized to perform this operation. You must be a Dendro administrator."
            },
            user: {
                type: Permissions.types.role_in_system,
                predicate: "rdf:type",
                object: "ddr:User",
                error_message_user: "You are not authorized to perform this operation. You must be signed into Dendro.",
                error_message_api: "Error detected. You are not authorized to perform this operation. You must be signed into Dendro."
            }
        },
        in_project: {
            creator: {
                type: Permissions.types.role_in_project,
                predicate: "dcterms:creator",
                error_message_user: "Error trying to access a project or a file / folder within a project that you have not created.",
                error_message_api: "Unauthorized access. Must be signed on as a creator of this project."
            },
            contributor: {
                type: Permissions.types.role_in_project,
                predicate: "dcterms:contributor",
                error_message_user: "You are not a contributor of this project or of the project to which this resource belongs to.",
                error_message_api: "Unauthorized access. Must be signed on as a contributor of this project."
            }
        },
        in_owner_project: {
            creator: {
                type: Permissions.types.role_in_owner_project,
                predicate: "dcterms:creator",
                error_message_user: "Error trying to access a project or a file / folder within a project that you have not created.",
                error_message_api: "Unauthorized access. Must be signed on as a creator of the project the resource belongs to."
            },
            contributor: {
                type: Permissions.types.role_in_owner_project,
                predicate: "dcterms:contributor",
                error_message_user: "You are not a contributor of this project or of the project to which this resource belongs to.",
                error_message_api: "Unauthorized access. Must be signed on as a contributor of the project the resource belongs to."
            }
        },
        in_notification_s_resource: {
            author: {
                type: Permissions.types.role_in_notification_s_resource,
                predicate: "ddr:resourceAuthorUri",
                error_message_user: "You are not the author of the resource that this notification points to.",
                error_message_api: "Unauthorized access. Must be signed on as the author of the resource that this notification points to."
            }
        },
        in_post_s_project: {
            creator: {
                type: Permissions.types.role_in_post_s_project,
                predicate: "dcterms:creator",
                error_message_user: "You are not a contributor or creator of the project to which this post belongs to.",
                error_message_api: "Unauthorized access. Must be signed on as a contributor or creator of the project the post belongs to."
            },
            contributor: {
                type: Permissions.types.role_in_post_s_project,
                predicate: "dcterms:contributor",
                error_message_user: "You are not a contributor or creator of the project to which this post belongs to.",
                error_message_api: "Unauthorized access. Must be signed on as a contributor or creator of the project the post belongs to."
            }
        },
        user_role_in_array_of_posts_project: {
            type: Permissions.types.user_role_in_array_of_posts_project,
            predicates: [
                "dcterms:creator"
            ],
            error_message_user: "You are not a contributor or creator of all the projects to which these posts belongs to.",
            error_message_api: "Unauthorized access. Must be signed on as a contributor or creator of all the projects these posts belong to."
        },
        users_role_in_deposit: {
            type: Permissions.types.role_in_deposit,
            predicates: [
                "dcterms:creator"
            ],
            error_message_user: "You are not a contributor or creator of project to which this deposit belongs to.",
            error_message_api: "Unauthorized access. Must be signed on as a contributor or creator of the project this deposit belong to."
        },
        in_deposit: {
            creator: {
                type: Permissions.types.role_in_deposit,
                predicates: [
                    "dcterms:creator"
                ],
                error_message_user: "Error trying to access a deposit or a file / folder within a deposit that you have not created.",
                error_message_api: "Unauthorized access. Must be signed on as a creator of this deposit."
            }
        }
    },
    privacy: {
        of_project: {
            public: {
                type: Permissions.types.privacy_of_project,
                predicate: "ddr:privacyStatus",
                object: "public",
                error_message_user: "This is a public project.",
                error_message_api: "This is a public project."
            },
            private: {
                type: Permissions.types.privacy_of_project,
                predicate: "ddr:privacyStatus",
                object: "private",
                error_message_user: "This is a private project, and neither data nor metadata can be accessed.",
                error_message_api: "Unauthorized Access. This is a private project, and neither data nor metadata can be accessed."
            },
            metadata_only: {
                type: Permissions.types.privacy_of_project,
                predicate: "ddr:privacyStatus",
                object: "metadata_only",
                error_message_user: "This is a project with only metadata access. Data metadata cannot be accessed.",
                error_message_api: "Unauthorized Access. This is a project with only metadata access. Data metadata cannot be accessed."
            }
        },
        of_owner_project: {
            public: {
                type: Permissions.types.privacy_of_owner_project,
                predicate: "ddr:privacyStatus",
                object: "public",
                error_message_user: "This is a resource that belongs to a public project.",
                error_message_api: "This is a resource that belongs to a public project."
            },
            private: {
                type: Permissions.types.privacy_of_owner_project,
                predicate: "ddr:privacyStatus",
                object: "private",
                error_message_user: "This is a resource that belongs to a private project, and neither data nor metadata can be accessed.",
                error_message_api: "Unauthorized Access. This is a resource that belongs to a private project, and neither data nor metadata can be accessed."
            },
            metadata_only: {
                type: Permissions.types.privacy_of_owner_project,
                predicate: "ddr:privacyStatus",
                object: "metadata_only",
                error_message_user: "This is a resource that belongs to a project with only metadata access. Data metadata cannot be accessed.",
                error_message_api: "Unauthorized Access. This is a resource that belongs to a project with only metadata access. Data metadata cannot be accessed."
            }
        },
        of_deposit: {
            public: {
                type: Permissions.types.privacy_of_deposit,
                predicate: "ddr:privacyStatus",
                object: "public",
                error_message_user: "This is a resource that belongs to a public deposit",
                error_message_api: "This is a resource that belongs to a public deposit"
            },
            private: {
                type: Permissions.types.privacy_of_deposit,
                predicate: "ddr:privacyStatus",
                object: "private",
                error_message_user: "This is a resource that belongs to a private deposit, and neither data nor metadata can be accessed.",
                error_message_api: "Unauthorized Access. This is a resource that belongs to a private deposit, and neither data nor metadata can be accessed."
            },
            metadata_only: {
                type: Permissions.types.privacy_of_deposit,
                predicate: "ddr:privacyStatus",
                object: "metadata_only",
                error_message_user: "This is a resource that belongs to a deposit with only metadata access. Data metadata cannot be accessed.",
                error_message_api: "Unauthorized Access. This is a resource that belongs to a project with only metadata access. Data metadata cannot be accessed."
            }
        }
    },
    permission: {
        on_deposit: {
            type: Permissions.types.permission_on_deposit,
            predicates: [
                "ddr:acceptingUser",
                "ddr:dataset",
                "ddr:userAccepted"
            ],
            error_message_user: "Error trying to access the resources that do not have access",
            error_message_api: "Unauthorized access. You must have permission to visualize this deposit."
        }
    }
};

/** Permissions checking logic **/

Permissions.addToReasons = function (req, reason, authorizing)
{
    if (isNull(req.permissions_management))
    {
        req.permissions_management = {};
    }

    if (authorizing)
    {
        req.permissions_management.reasons_for_authorizing = _.compact(_.flatten([].concat(req.permissions_management.reasons_for_authorizing).concat([reason])));
    }
    else
    {
        req.permissions_management.reasons_for_denying = _.compact(_.flatten([].concat(req.permissions_management.reasons_for_denying).concat([reason])));
    }

    return req;
};

Permissions.check = function (permissionsRequired, req, callback)
{
    // Global Administrators are God, so they dont go through any checks
    if (!req.session.isAdmin)
    {
        const resource = req.params.requestedResourceUri;
        const user = req.user;

        const checkPermission = function (req, user, resource, permission, cb)
        {
            if (permission.type === Permissions.types.role_in_system)
            {
                Permissions.types.role_in_system.validator(req, user, permission, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.role_in_project)
            {
                Permissions.types.role_in_project.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type.validator.name === Permissions.types.role_in_owner_project.validator.name)
            {
                Permissions.types.role_in_owner_project.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.privacy_of_project)
            {
                Permissions.types.privacy_of_project.validator(req, permission, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.privacy_of_owner_project)
            {
                Permissions.types.privacy_of_owner_project.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.role_in_post_s_project)
            {
                Permissions.types.role_in_post_s_project.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.user_role_in_array_of_posts_project)
            {
                Permissions.types.user_role_in_array_of_posts_project.validator(req, user, permission, req.query.postsQueryInfo, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.role_in_notification_s_resource)
            {
                Permissions.types.role_in_notification_s_resource.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.privacy_of_deposit)
            {
                /* Permissions.types.role_in_system.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });*/
                cb(null, {authorized: true, role: "permission"});
            }
            else if (permission.type === Permissions.types.role_in_deposit)
            {
                Permissions.types.role_in_deposit.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else if (permission.type === Permissions.types.permission_on_deposit)
            {
                Permissions.types.permission_on_deposit.validator(req, user, permission, resource, function (err, result)
                {
                    cb(err, {authorized: result, role: permission});
                });
            }
            else
            {
                cb(null,
                    {
                        authorized: false,
                        role: "Type of permission required is badly configured. Ask your administrator to review your Dendro server's configuration."
                    }
                );
            }
        };

        if (permissionsRequired instanceof Array &amp;&amp; permissionsRequired.length > 0)
        {
            async.mapSeries(permissionsRequired,
                async.apply(checkPermission, req, user, resource),
                function (err, results)
                {
                    const reasonsForDenying = _.filter(results, function (result)
                    {
                        if (!isNull(result))
                        {
                            return !result.authorized;
                        }
                        return false;
                    });

                    const reasonsForAuthorizing = _.filter(results, function (result)
                    {
                        if (!isNull(result))
                        {
                            return result.authorized;
                        }
                        return false;
                    });

                    req = Permissions.addToReasons(req, reasonsForDenying, false);

                    req = Permissions.addToReasons(req, reasonsForAuthorizing, true);

                    return callback(err, req, results);
                }
            );
        }
        else
        {
            const reasonsForAllowing = [{
                authorized: true,
                role: "Anyone"
            }];

            req = Permissions.addToReasons(req, reasonsForAllowing, true);

            return callback(null, req, reasonsForAllowing);
        }
    }
    else
    {
        const reasonsForAllowing = [{
            authorized: true,
            role: Permissions.types.role_in_system.admin
        }];

        req = Permissions.addToReasons(req, reasonsForAllowing, true);

        return callback(null, req, reasonsForAllowing);
    }
};

Permissions.require = function (permissionsRequired, req, res, next)
{
    if (Config.debug.permissions.enable_permissions_system)
    {
        if (Config.debug.active &amp;&amp; Config.debug.permissions.log_requests_and_permissions)
        {
            Logger.log("[REQUEST] : Checking for permissions on request " + req.originalUrl);
            Logger.log(JSON.stringify(permissionsRequired, null, 2));
        }
        // Global Administrators are God, so they dont go through any checks
        if (!req.session.isAdmin)
        {
            Permissions.check(permissionsRequired, req, function (err, req)
            {
                if (req.permissions_management.reasons_for_authorizing.length > 0)
                {
                    if (Config.debug.active &amp;&amp; Config.debug.permissions.log_authorizations)
                    {
                        Logger.log("[AUTHORIZED] : Checking for permissions on request " + req.originalUrl);
                        Logger.log(JSON.stringify(req.permissions_management.reasons_for_authorizing.length, null, 2));
                    }

                    return Permissions.sendResponse(true, req, res, next, req.permissions_management.reasons_for_authorizing);
                }
                else if (req.permissions_management.reasons_for_denying.length > 0)
                {
                    if (Config.debug.active &amp;&amp; Config.debug.permissions.log_denials)
                    {
                        Logger.log("[DENIED] : Checking for permissions on request " + req.originalUrl);
                        Logger.log(JSON.stringify(req.permissions_management.reasons_for_authorizing.length, null, 2));
                        Logger.log(JSON.stringify(req.permissions_management.reasons_for_denying, null, 2));
                    }

                    return Permissions.sendResponse(false, req, res, next, req.permissions_management.reasons_for_denying);
                }
                // ommision case. No reasons to authorize nor to refuse access!
                return Permissions.sendResponse(true, req, res, next, []);
            });
        }
        else
        {
            return Permissions.sendResponse(true, req, res, next, [Permissions.settings.role.in_system.admin]);
        }
    }
    else
    {
        next();
    }
};

exports.Permissions = Permissions;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 23 2019 22:03:50 GMT+0100 (WEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
