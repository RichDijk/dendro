<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>src/controllers/standalone_recommendation.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#arrayContainsArray">arrayContainsArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildCkanFileIDsFromDendroFileNames">buildCkanFileIDsFromDendroFileNames</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildExtrasJSONArray">buildExtrasJSONArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildPackageForCkanExport">buildPackageForCkanExport</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#buildPermissionsToBeCheck">buildPermissionsToBeCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#calculateCkanRepositoryDiffs">calculateCkanRepositoryDiffs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#calculateDendroDiffs">calculateDendroDiffs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkIfFolderAndTargetRepositoryHaveRequiredMetadata">checkIfFolderAndTargetRepositoryHaveRequiredMetadata</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkIfResourceHasTheRequiredMetadataForExport">checkIfResourceHasTheRequiredMetadataForExport</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkPrivacyOfProject">checkPrivacyOfProject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#checkResourceTypeAndChildren">checkResourceTypeAndChildren</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#checkRoleInSystem">checkRoleInSystem</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#Config">Config</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createCkanFileIdBasedOnDendroFileName">createCkanFileIdBasedOnDendroFileName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createOrUpdateFilesInPackage">createOrUpdateFilesInPackage</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createPackageID">createPackageID</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createPackageInCkan">createPackageInCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#deleteResourceInCkan">deleteResourceInCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#exportPackageToCkan">exportPackageToCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#get_recommendations">get_recommendations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getAllPosts">getAllPosts</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getBothDendroDiffsAndCkanDiffs">getBothDendroDiffsAndCkanDiffs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getExportedAtByDendroForCkanDataset">getExportedAtByDendroForCkanDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#isObject">isObject</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#jarPath">jarPath</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#mergeDeep">mergeDeep</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#purgeCkanDataset">purgeCkanDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#register_interaction">register_interaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#repository_types">repository_types</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#request">request</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#updateOrInsertExportedAtByDendroForCkanDataset">updateOrInsertExportedAtByDendroForCkanDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#updatePackageInCkan">updatePackageInCkan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#validateChangesPermissions">validateChangesPermissions</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#verifyIfCkanFileWasCreatedInDendro">verifyIfCkanFileWasCreatedInDendro</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">src/controllers/standalone_recommendation.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require("path");
const rlequire = require("rlequire");
const IndexConnection = rlequire("dendro", "src/kb/index.js").IndexConnection;
const Logger = rlequire("dendro", "src/utils/logger.js").Logger;
const Config = rlequire("dendro", "src/models/meta/config.js").Config;

const isNull = rlequire("dendro", "src/utils/null.js").isNull;
const Elements = rlequire("dendro", "src/models/meta/elements.js").Elements;
const Logger = rlequire("dendro", "src/utils/logger.js").Logger;

const Descriptor = rlequire("dendro", "src/models/meta/descriptor.js").Descriptor;
const Ontology = rlequire("dendro", "src/models/meta/ontology.js").Ontology;
const Interaction = rlequire("dendro", "src/models/recommendation/interaction.js").Interaction;
const Resource = rlequire("dendro", "src/models/resource.js").Resource;
const InformationElement = rlequire("dendro", "src/models/directory_structure/information_element.js").InformationElement;
const User = rlequire("dendro", "src/models/user.js").User;

const async = require("async");
const _ = require("underscore");

exports.recommend_descriptors = function (req, res)
{
    if (!isNull(req.params.requestedResourceUri))
    {
        if (!isNull(req.user))
        {
            const recommendationMode = req.query.recommendations_mode;

            const getAllowedOntologies = function ()
            {
                if (!isNull(req.user.recommendations) &amp;&amp; !isNull(req.user.recommendations.ontologies))
                {
                    const acceptedOntologies = req.user.recommendations.ontologies.accepted;
                    const fullOntologies = [];

                    for (let prefix in acceptedOntologies)
                    {
                        if (acceptedOntologies.hasOwnProperty(prefix))
                        {
                            const ontology = new Ontology({
                                prefix: prefix
                            });

                            fullOntologies.push(ontology.uri);
                        }
                    }

                    return fullOntologies;
                }
            };

            const registerRecommendationRequestInteraction = function ()
            {
                if (!isNull(req.query.page))
                {
                    let oldPage = req.user.recommendations.descriptor_page;

                    if (isNull(oldPage))
                    {
                        oldPage = 0;
                    }

                    const newPage = parseInt(req.query.page);

                    req.user.recommendations.descriptor_page = newPage;

                    let interactionType;

                    if (newPage === (oldPage + 1))
                    {
                        interactionType = Interaction.types.browse_to_next_page_in_descriptor_list.key;
                    }
                    else if (newPage === (oldPage - 1))
                    {
                        interactionType = Interaction.types.browse_to_previous_page_in_descriptor_list.key;
                    }

                    if (!isNull(interactionType))
                    {
                        const lastRecommendationList = JSON.stringify(req.user.recommendations.lastRecommendationList);

                        Interaction.create(
                            {
                                ddr: {
                                    performedBy: req.user.uri,
                                    interactionType: interactionType,
                                    lastDescriptorRecommendationsList: lastRecommendationList,
                                    originallyRecommendedFor: req.params.requestedResourceUri
                                }
                            },
                            function (err, interaction)
                            {
                                if (isNull(err) &amp;&amp; !isNull(interaction))
                                {
                                    interaction.save(function (err, interaction)
                                    {
                                        if (err)
                                        {
                                            console.err("Unable to record interaction of type " + interactionType + " for shifting between pages in the descriptor recommender list. ");
                                        }
                                        else
                                        {
                                            Logger.log("Successfully recorded interaction of type " + interactionType + " for shifting between pages in the descriptor recommender list in resource with uri " + req.params.requestedResourceUri);
                                        }
                                    });
                                }
                            });
                    }
                }
            };

            const allowedOntologies = getAllowedOntologies();

            exports.shared.recommend_descriptors(req.params.requestedResourceUri, req.user.uri, req.query.page, allowedOntologies, IndexConnection.getDefault(), function (err, descriptors)
            {
                if (isNull(err))
                {
                    registerRecommendationRequestInteraction();

                    req.user.recommendations.lastRecommendationList = descriptors;
                    res.json(
                        {
                            result: "ok",
                            descriptors: descriptors
                        }
                    );
                }
                else
                {
                    res.status(500).json(
                        {
                            result: "error",
                            error_messages: ["Error producing metadata recommendations for resource " + req.params.requestedResourceUri + " . Error reported : " + descriptors]
                        }
                    );
                }
            },
            {
                favorites: (recommendationMode === exports.shared.recommendation_options.favorites),
                smart: (recommendationMode === exports.shared.recommendation_options.smart),
                hidden: (recommendationMode === exports.shared.recommendation_options.hidden)
            });
        }
        else
        {
            res.status(400).json(
                {
                    result: "error",
                    error_messages: ["No user is authenticated in the system, so no metadata recommendations can be obtained."]
                }
            );
        }
    }
    else
    {
        res.status(404).json(
            {
                result: "error",
                error_messages: ["Resource with uri ." + req.params.requestedResourceUri + " does not exist in this Dendro instance."]
            }
        );
    }
};

exports.shared = {};

/**
 * Recommends a page of descriptors
 * @param resourceUri
 * @param userUri
 * @param page
 * @param allowedOntologies
 * @param indexConnection
 * @param callback
 * @param options favorites_only : choose from favorite descriptors only
 */

exports.shared.recommendation_options = {
    favorites: "favorites",
    smart: "smart",
    hidden: "hidden"
};

exports.shared.recommend_descriptors = function (resourceUri, userUri, page, allowedOntologies, indexConnection, callback, options)
{
    const ie = new InformationElement(
        {
            uri: resourceUri
        }
    );

    ie.getOwnerProject(function (err, ownerProject)
    {
        const Project = rlequire("dendro", "src/models/project.js").Project;

        if (isNull(err) &amp;&amp; ownerProject instanceof Project)
        {
            const projectUri = ownerProject.uri;

            let includeOnlyFavorites = !isNull(options) &amp;&amp; options[exports.shared.recommendation_options.favorites];
            const smartRecommendationMode = !isNull(options) &amp;&amp; options[exports.shared.recommendation_options.smart];
            let includeOnlyHiddenDescriptors = !isNull(options) &amp;&amp; options[exports.shared.recommendation_options.hidden];

            /**
             * Get Most Used Descriptors
             * @param callback
             */
            const getMostUsedPublicDescriptors = function (callback)
            {
                Descriptor.mostUsedPublicDescriptors(Config.recommendation.max_suggestions_of_each_type, function (error, mostUsedDescriptors)
                {
                    return callback(error, mostUsedDescriptors);
                }, allowedOntologies);
            };

            /**
             * Get Recently Used Descriptors
             * @param callback
             */
            const getUsersMostUsedDescriptors = function (userUri, callback)
            {
                User.findByUri(userUri, function (err, user)
                {
                    if (isNull(err))
                    {
                        user.mostRecentlyFilledInDescriptors(Config.recommendation.max_suggestions_of_each_type, function (error, mostRecentlyFilledIn)
                        {
                            return callback(error, mostRecentlyFilledIn);
                        }, allowedOntologies);
                    }
                    else
                    {
                        const error = "Error fetching user : " + user + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            /**
             * Get User's favorite descriptors
             * @param callback
             */
            const getUsersFavoriteDescriptors = function (userUri, callback)
            {
                User.findByUri(userUri, function (err, user)
                {
                    if (isNull(err))
                    {
                        user.favoriteDescriptors(Config.recommendation.max_suggestions_of_each_type, function (error, favorites)
                        {
                            return callback(error, favorites);
                        }, allowedOntologies);
                    }
                    else
                    {
                        const error = "Error fetching user : " + user + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            /**
             * Get User's favorite descriptors
             * @param callback
             */
            const getUsersHiddenDescriptors = function (userUri, callback)
            {
                User.findByUri(userUri, function (err, user)
                {
                    if (isNull(err))
                    {
                        user.hiddenDescriptors(Config.recommendation.max_suggestions_of_each_type, function (error, hidden)
                        {
                            return callback(error, hidden);
                        }, allowedOntologies);
                    }
                    else
                    {
                        const error = "Error fetching user : " + user + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            /**
             * Get Project's favorite descriptors
             * @param callback
             */
            const getProjectsFavoriteDescriptors = function (projectUri, callback)
            {
                const Project = require("./project.js").Project;

                Project.findByUri(projectUri, function (err, project)
                {
                    if (isNull(err))
                    {
                        if (!isNull(project))
                        {
                            project.getFavoriteDescriptors(Config.recommendation.max_suggestions_of_each_type, function (error, favorites)
                            {
                                return callback(error, favorites);
                            }, allowedOntologies);
                        }
                        else
                        {
                            const error = "Project with uri : " + projectUri + " is not registered in this Dendro instance.";
                            Logger.log("error", error);
                            return callback(1, error);
                        }
                    }
                    else
                    {
                        const error = "Error fetching project : " + project + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            const getProjectsHiddenDescriptors = function (projectUri, callback)
            {
                const Project = require("./project.js").Project;

                Project.findByUri(projectUri, function (err, project)
                {
                    if (!isNull(err))
                    {
                        if (!isNull(project))
                        {
                            project.getHiddenDescriptors(Config.recommendation.max_suggestions_of_each_type, function (error, hidden)
                            {
                                return callback(error, hidden);
                            }, allowedOntologies);
                        }
                        else
                        {
                            const error = "Project with uri : " + projectUri + " is not registered in this Dendro instance.";
                            Logger.log("error", error);
                            return callback(1, error);
                        }
                    }
                    else
                    {
                        const error = "Error fetching project : " + project + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            /**
             * Get descriptors used in textually similar resources
             * @param callback
             */
            const getDescriptorsFromTextuallySimilarResources = function (resourceUri, callback)
            {
                const resource = new Resource(
                    {
                        uri: resourceUri
                    }
                );

                resource.getTextuallySimilarResources(function (err, similarResources)
                {
                    if (!isNull(err) &amp;&amp; !isNull(similarResources) &amp;&amp; similarResources instanceof Array)
                    {
                        // get properties of the similar resources
                        const getDescriptorsOfSimilarResources = function (resource, callback)
                        {
                            const descriptors = resource.getPropertiesFromOntologies(allowedOntologies);

                            for (let i = 0; i &lt; descriptors.length; i++)
                            {
                                descriptors[i].recommendation_types = {};
                                descriptors[i].recommendation_types[Descriptor.recommendation_types.from_textually_similar.key] = true;
                            }

                            return callback(null, resource); // null as 1st argument === no error
                        };

                        async.mapSeries(similarResources, getDescriptorsOfSimilarResources, function (err, similarResourcesWithDescriptors)
                        {
                            return callback(err, similarResourcesWithDescriptors);
                        });
                    }
                    else
                    {
                        const error = "Error fetching similar resources : " + similarResources + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                }, Config.limits.index.maxResults);
            };

            /**
             * Get user's favorite descriptors that are most accepted in the metadata editor
             */
            const getUsersMostAcceptedFavoriteDescriptorsInMetadataEditor = function (userUri, callback)
            {
                User.findByUri(userUri, function (err, user)
                {
                    if (isNull(isNull(err)))
                    {
                        user.mostAcceptedFavoriteDescriptorsInMetadataEditor(Config.recommendation.max_suggestions_of_each_type, function (error, hidden)
                        {
                            return callback(error, hidden);
                        }, allowedOntologies);
                    }
                    else
                    {
                        const error = "Error fetching user : " + user + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            /**
             * Get user's smart descriptors that are most accepted in the metadata editor
             */
            const getUsersMostAcceptedSmartDescriptorsInMetadataEditor = function (userUri, callback)
            {
                User.findByUri(userUri, function (err, user)
                {
                    if (isNull(err))
                    {
                        user.mostAcceptedSmartDescriptorsInMetadataEditor(Config.recommendation.max_suggestions_of_each_type, function (error, hidden)
                        {
                            return callback(error, hidden);
                        }, allowedOntologies);
                    }
                    else
                    {
                        const error = "Error fetching user : " + user + " : " + err;
                        Logger.log("error", error);
                        return callback(1, error);
                    }
                });
            };

            async.series(
                [
                    function (callback)
                    {
                        getMostUsedPublicDescriptors(callback); // 0
                    },
                    function (callback)
                    {
                        getUsersMostUsedDescriptors(userUri, callback); // 1
                    },
                    function (callback)
                    {
                        // only indexes that support "more like this" queries can be used
                        if(Config.index.type === "elasticsearch")
                        {
                            getDescriptorsFromTextuallySimilarResources(resourceUri, callback); // 2
                        }
                        else
                        {
                            callback(null, []);
                        }
                    },
                    function (callback)
                    {
                        getUsersFavoriteDescriptors(userUri, callback); // 3
                    },
                    function (callback)
                    {
                        getUsersHiddenDescriptors(userUri, callback); // 4
                    },
                    function (callback)
                    {
                        getProjectsFavoriteDescriptors(projectUri, callback); // 5
                    },
                    function (callback)
                    {
                        getProjectsHiddenDescriptors(projectUri, callback); // 6
                    },
                    function (callback)
                    {
                        getUsersMostAcceptedFavoriteDescriptorsInMetadataEditor(userUri, callback); // 7
                    },
                    function (callback)
                    {
                        getUsersMostAcceptedSmartDescriptorsInMetadataEditor(userUri, callback); // 8
                    }
                ],
                /**
                 * Perform final ranking
                 * @param callback
                 */
                function (err, results)
                {
                    if (isNull(err))
                    {
                        /**
                         * fill in with random descriptors from the currently
                         * allowed ontologies until we have the needed
                         * recommendations
                         * **/
                        const flattenAndMergeDescriptors = function (results)
                        {
                            const initDescriptorsHash = function (descriptorsArray)
                            {
                                const hash = {};

                                for (let i = 0; i &lt; descriptorsArray.length; i++)
                                {
                                    const descriptor = new Descriptor({
                                        uri: descriptorsArray[i].uri
                                    });

                                    if (isNull(hash[descriptor.prefix]))
                                    {
                                        hash[descriptor.prefix] = {};
                                    }

                                    if (isNull(hash[descriptor.prefix][descriptor.shortName]))
                                    {
                                        hash[descriptor.prefix][descriptor.shortName] = null;
                                    }
                                }

                                return hash;
                            };

                            const flatResults = _.compact(_.flatten(results));
                            const descriptors = initDescriptorsHash(flatResults);
                            let d;
                            let i;

                            for (i = 0; i &lt; flatResults.length; i++)
                            {
                                const dummyToParseUri = new Descriptor(flatResults[i]);
                                const descriptorPrefix = dummyToParseUri.prefix;
                                const descriptorShortName = dummyToParseUri.shortName;

                                d = descriptors[descriptorPrefix][descriptorShortName];

                                if (isNull(d))
                                {
                                    d = new Descriptor(flatResults[i]);
                                }

                                if (typeof flatResults[i].recent_use_count !== "undefined")
                                {
                                    d.recent_use_count = flatResults[i].recent_use_count;
                                }
                                if (typeof flatResults[i].overall_use_count !== "undefined")
                                {
                                    d.overall_use_count = flatResults[i].overall_use_count;
                                }
                                if (typeof flatResults[i].times_smart_accepted_in_md_editor !== "undefined")
                                {
                                    d.times_smart_accepted_in_md_editor = flatResults[i].times_smart_accepted_in_md_editor;
                                }
                                if (typeof flatResults[i].times_favorite_accepted_in_md_editor !== "undefined")
                                {
                                    d.times_favorite_accepted_in_md_editor = flatResults[i].times_favorite_accepted_in_md_editor;
                                }
                                if (typeof flatResults[i].last_use !== "undefined")
                                {
                                    d.last_use = flatResults[i].last_use;
                                }

                                descriptors[descriptorPrefix][descriptorShortName] = d;
                            }

                            for (i = 0; i &lt; flatResults.length; i++)
                            {
                                d = new Descriptor(flatResults[i]);

                                let fused_result_types = descriptors[d.prefix][d.shortName].recommendation_types;
                                if (typeof fused_result_types === "undefined")
                                {
                                    fused_result_types = {};
                                }

                                let result_rec_types;
                                if (flatResults[i].recommendation_types instanceof Object)
                                {
                                    try
                                    {
                                        result_rec_types = Object.keys(flatResults[i].recommendation_types);
                                    }
                                    catch (e)
                                    {
                                        Logger.log("error", "Estourei onde devia");
                                    }

                                    if (typeof result_rec_types === "undefined")
                                    {
                                        result_rec_types = [];
                                    }

                                    // copy rec types from the result
                                    for (let j = 0; j &lt; result_rec_types.length; j++)
                                    {
                                        const result_rec_type = result_rec_types[j];
                                        fused_result_types[result_rec_type] = true;
                                    }
                                }

                                descriptors[d.prefix][d.shortName].recommendation_types = fused_result_types;
                            }

                            const flatDescriptors = [];

                            for (let prefix in descriptors)
                            {
                                if (descriptors.hasOwnProperty(prefix))
                                {
                                    for (let shortName in descriptors[prefix])
                                    {
                                        if (descriptors[prefix].hasOwnProperty(shortName))
                                        {
                                            var descriptor = descriptors[prefix][shortName];

                                            if (includeOnlyFavorites)
                                            {
                                                if (descriptor.recommendation_types[Descriptor.recommendation_types.project_favorite.key] ||
                                                    descriptor.recommendation_types[Descriptor.recommendation_types.user_favorite.key])
                                                {
                                                    flatDescriptors.push(descriptor);
                                                }
                                            }
                                            else if (includeOnlyHiddenDescriptors)
                                            {
                                                if (descriptor.recommendation_types[Descriptor.recommendation_types.project_hidden.key] ||
                                                    descriptor.recommendation_types[Descriptor.recommendation_types.user_hidden.key])
                                                {
                                                    flatDescriptors.push(descriptor);
                                                }
                                            }
                                            else
                                            {
                                                flatDescriptors.push(descriptor);
                                            }
                                        }
                                    }
                                }
                            }

                            return flatDescriptors;
                        };

                        const rankDescriptors = function (descriptors)
                        {
                            for (let i = 0; i &lt; descriptors.length; i++)
                            {
                                var descriptor = descriptors[i];

                                // Logger.log("Ranking descriptor " + descriptor.prefixedForm);

                                let score = descriptor.score;

                                if (isNull(score))
                                {
                                    score = 0;
                                }

                                let rec_types = {};

                                if (typeof descriptor.recommendation_types !== "undefined")
                                {
                                    rec_types = descriptor.recommendation_types;
                                }
                                else
                                {
                                    rec_types = {};
                                }

                                // Hidden descriptors have Zero Score!
                                if (rec_types[Descriptor.recommendation_types.user_hidden.key] || rec_types[Descriptor.recommendation_types.project_hidden.key])
                                {
                                    score = 0;
                                }
                                else
                                {
                                    // if NOT hidden, calculate score
                                    if (rec_types[Descriptor.recommendation_types.recently_used.key])
                                    {
                                        score += descriptor.recent_use_count *
                                            Descriptor.recommendation_types.recently_used.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.from_textually_similar.key])
                                    {
                                        score += Descriptor.recommendation_types.from_textually_similar *
                                            Descriptor.recommendation_types.from_textually_similar.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.frequently_used_overall.key])
                                    {
                                        score += descriptor.overall_use_count *
                                            Descriptor.recommendation_types.frequently_used_overall.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.random.key])
                                    {
                                        score += Descriptor.recommendation_types.random.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.user_favorite.key])
                                    {
                                        score += Descriptor.recommendation_types.user_favorite.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.project_favorite.key])
                                    {
                                        score += Descriptor.recommendation_types.project_favorite.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.smart_accepted_in_metadata_editor.key])
                                    {
                                        score += descriptor.times_smart_accepted_in_md_editor *
                                            Descriptor.recommendation_types.smart_accepted_in_metadata_editor.weight;
                                    }
                                    if (rec_types[Descriptor.recommendation_types.favorite_accepted_in_metadata_editor.key])
                                    {
                                        score += descriptor.times_favorite_accepted_in_md_editor *
                                            Descriptor.recommendation_types.favorite_accepted_in_metadata_editor.weight;
                                    }
                                }

                                descriptor.score = score;
                                descriptors[i] = descriptor;
                            }

                            descriptors = _.sortBy(descriptors, function (descriptor)
                            {
                                return descriptor.score;
                            });

                            descriptors = descriptors.reverse();

                            return descriptors;
                        };

                        const applyPaging = function (rankedDescriptors, page)
                        {
                            if (!isNull(page))
                            {
                                const skip = page * Config.recommendation.recommendation_page_size;
                                rankedDescriptors = rankedDescriptors.slice(skip, skip + Config.recommendation.recommendation_page_size);
                            }
                            else
                            {
                                rankedDescriptors = rankedDescriptors.slice(0, Config.recommendation.recommendation_page_size);
                            }

                            return rankedDescriptors;
                        };

                        const padWithRandomDescriptors = function (results, callback)
                        {
                            const numberOfDescriptorsRequiredForPadding = Config.recommendation.recommendation_page_size - results.length;

                            Descriptor.getRandomDescriptors(allowedOntologies, numberOfDescriptorsRequiredForPadding, function (err, randomDescriptors)
                            {
                                if (isNull(err) &amp;&amp; !isNull(randomDescriptors))
                                {
                                    results = results.concat(randomDescriptors);
                                    return callback(err, results);
                                }
                                const msg = "Error occurred when padding recommended descriptors list with random descriptors: " + err + ". Error reported: " + JSON.stringify(randomDescriptors);
                                Logger.log("error", msg);
                                return callback(err, msg);
                            });
                        };

                        const removeDuplicates = function (results)
                        {
                            const uniques = _.uniq(results, false, function (result)
                            {
                                return result.uri;
                            });

                            return uniques;
                        };

                        const removeLockedAndPrivate = function (results)
                        {
                            const filtered = _.filter(results, function (result)
                            {
                                let isLockedOrPrivate = (result.locked || result.private);
                                return !isLockedOrPrivate;
                            });

                            return filtered;
                        };

                        results = flattenAndMergeDescriptors(results);
                        results = rankDescriptors(results);
                        results = removeLockedAndPrivate(results);

                        const uuid = require("uuid");
                        const recommendation_call_id = uuid.v4();
                        const recommendation_call_timestamp = new Date().toISOString();
                        for (var i = 0; i &lt; results.length; i++)
                        {
                            results[i].recommendationCallId = recommendation_call_id;
                            results[i].recommendationCallTimeStamp = recommendation_call_timestamp;
                        }

                        if (!includeOnlyFavorites &amp;&amp; !includeOnlyHiddenDescriptors)
                        {
                            results = applyPaging(results, page);
                        }

                        if (includeOnlyFavorites || includeOnlyHiddenDescriptors)
                        {
                            /**
                             * In case we only want favorites, no need to pad with random descriptors
                             */

                            return callback(null, results);
                        }
                        else if (results.length &lt; Config.recommendation.recommendation_page_size &amp;&amp; !includeOnlyFavorites &amp;&amp; !includeOnlyHiddenDescriptors)
                        {
                            padWithRandomDescriptors(results, function (err, results)
                            {
                                results = removeDuplicates(results);
                                return callback(err, results);
                            });
                        }
                        else
                        {
                            return callback(null, results);
                        }
                    }
                    else
                    {
                        const error_messages = [];
                        for (var i = 0; i &lt; results.length; i++)
                        {
                            if (!(results[i] instanceof Array))
                            {
                                error_messages.push(results[i]);
                            }
                        }

                        const msg = "Error performing final ranking of descriptors. Error reported : " + err + ", Errors reported  " + JSON.stringify(error_messages);
                        Logger.log(msg);
                        return callback(err, msg);
                    }
                });
        }
        else
        {
            callback(err, ownerProject);
        }
    });
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 23 2019 16:29:36 GMT+0100 (WEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
